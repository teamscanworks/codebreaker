// Code generated by schema-generate. DO NOT EDIT.

package types

import (
    "bytes"
    "encoding/json"
    "errors"
)

// Codebase 
type Codebase struct {
  CosmosSdkVersion string `json:"cosmos_sdk_version,omitempty"`
  CosmwasmEnabled bool `json:"cosmwasm_enabled,omitempty"`
  CosmwasmVersion string `json:"cosmwasm_version,omitempty"`
  GitRepo string `json:"git_repo,omitempty"`
  LibwasmVersion string `json:"libwasm-version,omitempty"`
  TendermintVersion string `json:"tendermint_version,omitempty"`
}

// ContractsItem 
type ContractsItem struct {
  BuildEnv string `json:"build_env"`
  BuildInfo string `json:"build_info"`
  Checksum string `json:"checksum"`
  CodeId int `json:"code_id"`
  ModuleName string `json:"module_name"`
  Org string `json:"org,omitempty"`
  ReleaseTag string `json:"release_tag"`
  Repository string `json:"repository"`
  SecurityContact string `json:"security_contact,omitempty"`
  Verified bool `json:"verified"`
}

// ContractsRegistry Contracts json is a metadata file that contains information about CosmWasm contract code in Cosmos chains.
type ContractsRegistry struct {
  Bech32Prefix string `json:"bech32_prefix"`
  ChainId string `json:"chain_id"`
  ChainName string `json:"chain_name"`
  Codebase *Codebase `json:"codebase,omitempty"`
  Contracts map[string]*ContractsItem `json:"contracts,omitempty"`
  NetworkType interface{} `json:"network_type,omitempty"`
  PrettyName string `json:"pretty_name,omitempty"`
}

func (strct *ContractsItem) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BuildEnv" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "build_env" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"build_env\": ")
	if tmp, err := json.Marshal(strct.BuildEnv); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "BuildInfo" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "build_info" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"build_info\": ")
	if tmp, err := json.Marshal(strct.BuildInfo); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Checksum" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "checksum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"checksum\": ")
	if tmp, err := json.Marshal(strct.Checksum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CodeId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "code_id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"code_id\": ")
	if tmp, err := json.Marshal(strct.CodeId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ModuleName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "module_name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"module_name\": ")
	if tmp, err := json.Marshal(strct.ModuleName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "org" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"org\": ")
	if tmp, err := json.Marshal(strct.Org); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ReleaseTag" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "release_tag" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"release_tag\": ")
	if tmp, err := json.Marshal(strct.ReleaseTag); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Repository" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "repository" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"repository\": ")
	if tmp, err := json.Marshal(strct.Repository); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "security_contact" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"security_contact\": ")
	if tmp, err := json.Marshal(strct.SecurityContact); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Verified" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "verified" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"verified\": ")
	if tmp, err := json.Marshal(strct.Verified); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ContractsItem) UnmarshalJSON(b []byte) error {
    build_envReceived := false
    build_infoReceived := false
    checksumReceived := false
    code_idReceived := false
    module_nameReceived := false
    release_tagReceived := false
    repositoryReceived := false
    verifiedReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "build_env":
            if err := json.Unmarshal([]byte(v), &strct.BuildEnv); err != nil {
                return err
             }
            build_envReceived = true
        case "build_info":
            if err := json.Unmarshal([]byte(v), &strct.BuildInfo); err != nil {
                return err
             }
            build_infoReceived = true
        case "checksum":
            if err := json.Unmarshal([]byte(v), &strct.Checksum); err != nil {
                return err
             }
            checksumReceived = true
        case "code_id":
            if err := json.Unmarshal([]byte(v), &strct.CodeId); err != nil {
                return err
             }
            code_idReceived = true
        case "module_name":
            if err := json.Unmarshal([]byte(v), &strct.ModuleName); err != nil {
                return err
             }
            module_nameReceived = true
        case "org":
            if err := json.Unmarshal([]byte(v), &strct.Org); err != nil {
                return err
             }
        case "release_tag":
            if err := json.Unmarshal([]byte(v), &strct.ReleaseTag); err != nil {
                return err
             }
            release_tagReceived = true
        case "repository":
            if err := json.Unmarshal([]byte(v), &strct.Repository); err != nil {
                return err
             }
            repositoryReceived = true
        case "security_contact":
            if err := json.Unmarshal([]byte(v), &strct.SecurityContact); err != nil {
                return err
             }
        case "verified":
            if err := json.Unmarshal([]byte(v), &strct.Verified); err != nil {
                return err
             }
            verifiedReceived = true
        }
    }
    // check if build_env (a required property) was received
    if !build_envReceived {
        return errors.New("\"build_env\" is required but was not present")
    }
    // check if build_info (a required property) was received
    if !build_infoReceived {
        return errors.New("\"build_info\" is required but was not present")
    }
    // check if checksum (a required property) was received
    if !checksumReceived {
        return errors.New("\"checksum\" is required but was not present")
    }
    // check if code_id (a required property) was received
    if !code_idReceived {
        return errors.New("\"code_id\" is required but was not present")
    }
    // check if module_name (a required property) was received
    if !module_nameReceived {
        return errors.New("\"module_name\" is required but was not present")
    }
    // check if release_tag (a required property) was received
    if !release_tagReceived {
        return errors.New("\"release_tag\" is required but was not present")
    }
    // check if repository (a required property) was received
    if !repositoryReceived {
        return errors.New("\"repository\" is required but was not present")
    }
    // check if verified (a required property) was received
    if !verifiedReceived {
        return errors.New("\"verified\" is required but was not present")
    }
    return nil
}

func (strct *ContractsRegistry) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Bech32Prefix" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "bech32_prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"bech32_prefix\": ")
	if tmp, err := json.Marshal(strct.Bech32Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ChainId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "chain_id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"chain_id\": ")
	if tmp, err := json.Marshal(strct.ChainId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ChainName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "chain_name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"chain_name\": ")
	if tmp, err := json.Marshal(strct.ChainName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "codebase" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"codebase\": ")
	if tmp, err := json.Marshal(strct.Codebase); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "contracts" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"contracts\": ")
	if tmp, err := json.Marshal(strct.Contracts); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "network_type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"network_type\": ")
	if tmp, err := json.Marshal(strct.NetworkType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "pretty_name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"pretty_name\": ")
	if tmp, err := json.Marshal(strct.PrettyName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ContractsRegistry) UnmarshalJSON(b []byte) error {
    bech32_prefixReceived := false
    chain_idReceived := false
    chain_nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "bech32_prefix":
            if err := json.Unmarshal([]byte(v), &strct.Bech32Prefix); err != nil {
                return err
             }
            bech32_prefixReceived = true
        case "chain_id":
            if err := json.Unmarshal([]byte(v), &strct.ChainId); err != nil {
                return err
             }
            chain_idReceived = true
        case "chain_name":
            if err := json.Unmarshal([]byte(v), &strct.ChainName); err != nil {
                return err
             }
            chain_nameReceived = true
        case "codebase":
            if err := json.Unmarshal([]byte(v), &strct.Codebase); err != nil {
                return err
             }
        case "contracts":
            if err := json.Unmarshal([]byte(v), &strct.Contracts); err != nil {
                return err
             }
        case "network_type":
            if err := json.Unmarshal([]byte(v), &strct.NetworkType); err != nil {
                return err
             }
        case "pretty_name":
            if err := json.Unmarshal([]byte(v), &strct.PrettyName); err != nil {
                return err
             }
        }
    }
    // check if bech32_prefix (a required property) was received
    if !bech32_prefixReceived {
        return errors.New("\"bech32_prefix\" is required but was not present")
    }
    // check if chain_id (a required property) was received
    if !chain_idReceived {
        return errors.New("\"chain_id\" is required but was not present")
    }
    // check if chain_name (a required property) was received
    if !chain_nameReceived {
        return errors.New("\"chain_name\" is required but was not present")
    }
    return nil
}
